# ShyISA-完整指令集架构定义

## 1. 基础设计

ShyISA 是一个面向教学的汇编语言设计，其设计的哲学是足够简单，友好，帮助初学者入门计算机体系架构。

### 1.1 寄存器架构

系统包含16个**32位**通用寄存器，采用独特的命名方式：1x, 2x, 3x...fx，即16进制数后加字母x。这种命名既简洁又能直观反映寄存器编号。

除通用寄存器外，系统还配备了多个**32位**专用寄存器:

- **程序计数器(PC)**：指向下一条待执行指令
- **栈指针寄存器(SP)**：管理栈空间，**需由程序员手动初始化**
- **判断结果寄存器(RS)**：存储比较和条件判断的结果
- **退出寄存器(EX)**：任何改变都会触发程序退出
- **模式切换寄存器(MD)**：控制文字/图形显示模式

### 1.2 中断系统

定时器中断机制由三个寄存器协同工作：

- **TM寄存器**：定时值寄存器，每10毫秒自动减1。当减到1时触发硬件中断，默认值为0
- **TA1寄存器**：中断处理程序入口地址
- **TA2寄存器**：中断返回地址存储位置

中断处理流程：当TM减到1时，系统自动将当前PC值保存到TA2，然后跳转到TA1指向的中断处理程序。中断处理完成后应跳转回TA2以恢复正常执行。

### 1.3 内存架构

ShyISA采用**32位**寻址系统，每个地址对应一个**32位字**而非字节。这种设计简化了内存访问，使每条指令和数据都对齐在字边界上。

系统还提供了高效的块内存传输机制，通过两个专用寄存器实现：

- **BLTS寄存器**：存储传输源的首地址
- **BLTL寄存器**：指定传输长度

使用blt指令配合目标地址即可完成整块内存的快速复制。

### 1.4 I/O子系统

#### 声音系统

四个声音寄存器(M1-M4)分别产生不同波形：

- M1：正弦波
- M2：方波
- M3：三角波
- M4：锯齿波

每个寄存器独立工作，值为0时静音，非0值表示播放频率。

#### 显示系统

系统默认配备**256x256**分辨率的显示器，最大可支持到1024x1024

显存映射到0x00000100 到 0x00100100

取大小足够的低位

例如256x256 的显示器，则取0x00000100到0x00010100的范围为显存

#### 键盘输入

键盘通过内存映射方式访问，包括方向键(上下左右)、控制键(Enter、ESC)以及完整的ASCII字符集。

### 1.5 指令集设计理念

ShyISA的指令集遵循统一的设计原则：

- 固定长度编码：每条指令占**3个32位字**(指令码+参数1+参数2)
- 双操作数架构：绝大多数指令采用双参数格式
- 灵活的寻址模式：通过指令后缀区分地址(a)和立即数(n)操作

核心设计哲学是"一切皆地址"——指令、寄存器、内存、I/O设备都通过统一的地址空间访问，这种设计极大简化了系统架构的理解和实现。

## 2. 地址设计

ShyISA采用统一的地址空间设计，将所有资源映射到**32位**地址范围内。

### 2.1 寄存器地址映射

通用寄存器占据地址空间的最低16个位置：

- **0x00-0x0F**：16个通用寄存器(1x-Fx)

特殊寄存器紧随其后：

- **0x10**：程序计数器(PC)
- **0x11**：模式切换寄存器(MD)
- **0x12**：栈指针寄存器(SP)
- **0x13-0x15**：定时器相关寄存器(TM, TA1, TA2)
- **0x16-0x19**：声音寄存器(M1-M4)
- **0x1A**：结果寄存器(RS)
- **0x1B**：退出寄存器(EX)
- **0x1C-0x1D**：块传输寄存器(BLTS, BLTL)
- **0x1E-0x1F**：保留地址

### 2.2 指令空间

指令操作码占据0x20-0x6F地址范围，为未来扩展预留了充足空间。

### 2.3 I/O设备映射

键盘输入通过内存映射实现：

- **0x70-0x76**：方向键和控制键(上、下、左、右、Enter、ESC)
- **0x77-0x7F**：保留用于扩展控制键
- **0x80-0xFF**：ASCII码字符映射

### 2.4 内存布局

系统从 **0x00100100** 开始的内存空间完全可读写，提供了灵活的内存管理方案。代码段长度可精确预测，因此用户可根据需求自定义内存布局，甚至实现代码自修改。

系统仅有两个硬性约束：

1. **程序员必须在程序开始时手动初始化栈指针(SP)**，例如 `setn sp 0xEFFFFFFF`。
2. 程序从 **0x00100100** 地址开始执行。

## 3. 算术运算约定

ShyISA的算术运算遵循简单而一致的规则：

### 3.1 数值表示

所有算术运算均采用无符号数表示。

### 3.2 溢出处理

运算结果超出**32位**范围时，系统自动截断高位，保留低**32位**结果。

### 3.3 除法特殊情况

除以零操作不会引发异常，而是返回最大值 **0xFFFFFFFF** 作为结果。

### 3.4 条件判断机制

所有比较指令通过RS寄存器反馈结果：条件成立时RS置1，不成立时置0。

## 4. 软件约定

### 4.1 程序加载

系统通过串口或其他通信方式接收完整的内存镜像文件。镜像直接映射到内存地址空间，无需额外的加载过程。

### 4.2 指令编码格式

每条指令遵循统一的三字格式：

- **第一个字**：指令操作码地址
- **第二个字**：参数1
- **第三个字**：参数2

单参数或无参数指令自动在未使用的参数位置填充0，保证所有指令长度一致。

### 4.3 二进制文件格式

最终生成的可执行文件采用 `.sfs`扩展名(ShyISA File System)，文件格式

应当是完整内存映射。

sfs的大小取决于内存大小，不应小于0x00100100（这是我们保留的空间，约1m）

注：编译器和模拟器可优先实现2m，4m，8m等固定大小

注2：由于程序自行分配0x00100100后的空间，sfs的空间应当符合程序要求，如程序使用了0x00200000，那么sfs就不应该小于2m

### 5.1 程序结构

ShyISA汇编程序由三个主要部分组成，每部分都有的程序指令，支持标签定义用于跳转和函数调用。

### 5.2 汇编示例

下面是一个完整的ShyISA汇编程序示例，展示了各部分的使用方法：

```

___DEFINE___

SP sp              // 定义栈指针别名

PI 314159          // 定义常量PI



___DATA___

// 数据初始化支持多种格式

//这里相当于往堆空间初始化全局变量



0x00210000 "Hello!" // 字符串

0x00200000 'A'      // 单字符ASCII码

0x00200001 12345678 // 32位立即数

0x00200002 {111, 222, 114514}  // 数组初始化，支持32位立即数，以及单字符
/*也支持这种注释*/
/*还支持0x 0X开头的十六进制以及 b结尾的二进制
example：0x114 0X514 1100b */


___CODE___

setn sp 0x00FFFFFF // 手动初始化栈指针

setn 1x 1          // 将寄存器1x设置为1

.start             // 定义标签，对应下一条指令地址(0x01000006)

addn 0x00200001 1  // 地址0x00200001的值加1

outaasc 0x00200000 // 输出ASCII字符

outn PI            // 输出宏定义的常量

addn 1x 1          // 寄存器1x加1

sman 1x 10         // 比较1x是否小于10

jmpn .start        // 如果条件成立，跳转到标签.start

```

这个示例展示了宏定义、数据初始化、基本运算、I/O操作和条件跳转等核心功能的使用。

## 6. 指令集

### **指令集参考表**

| 16 进制地址                | 命令名称    | 命令格式                        | 描述                                                                                                                             |
| :------------------------- | :---------- | :------------------------------ | :------------------------------------------------------------------------------------------------------------------------------- |
| **算术运算指令**     |             |                                 |                                                                                                                                  |
| `0x20`                   | `adda`    | `adda <address> <address>`    | 将两个地址中的值相加，结果存储在第一个地址中。                                                                                   |
| `0x21`                   | `addn`    | `addn <address> <number>`     | 将一个地址中的值与一个数字相加，结果存储在该地址中。                                                                             |
| `0x22`                   | `suba`    | `suba <address> <address>`    | 将第一个地址中的值减去第二个地址中的值，结果存储在第一个地址中。                                                                 |
| `0x23`                   | `subn`    | `subn <address> <number>`     | 将一个地址中的值减去一个数字，结果存储在该地址中。                                                                               |
| `0x24`                   | `mula`    | `mula <address> <address>`    | 将两个地址中的值相乘，结果存储在第一个地址中。                                                                                   |
| `0x25`                   | `muln`    | `muln <address> <number>`     | 将一个地址中的值与一个数字相乘，结果存储在该地址中。                                                                             |
| `0x26`                   | `diva`    | `diva <address> <address>`    | 将第一个地址中的值除以第二个地址中的值，结果存储在第一个地址中。无符号除法，除以0时结果为 `0xFFFFFFFF`。                       |
| `0x27`                   | `divn`    | `divn <address> <number>`     | 将一个地址中的值除以一个数字，结果存储在该地址中。无符号除法，除以0时结果为 `0xFFFFFFFF`。                                     |
| **位运算指令**       |             |                                 |                                                                                                                                  |
| `0x28`                   | `lsa`     | `lsa <address> <address>`     | 将第一个地址中的值左移第二个地址中的值位，结果存储在第一个地址中。                                                               |
| `0x29`                   | `lsn`     | `lsn <address> <number>`      | 将一个地址中的值左移一定位数，结果存储在该地址中。                                                                               |
| `0x2A`                   | `rsa`     | `rsa <address> <address>`     | 将第一个地址中的值右移第二个地址中的值位，结果存储在第一个地址中。                                                               |
| `0x2B`                   | `rsn`     | `rsn <address> <number>`      | 将一个地址中的值右移一定位数，结果存储在该地址中。                                                                               |
| `0x2C`                   | `anda`    | `anda <address> <address>`    | 将两个地址中的值进行与运算，结果存储在第一个地址中。                                                                             |
| `0x2D`                   | `andn`    | `andn <address> <number>`     | 将一个地址中的值与一个数字进行与运算，结果存储在该地址中。                                                                       |
| `0x2E`                   | `ora`     | `ora <address> <address>`     | 将两个地址中的值进行或运算，结果存储在第一个地址中。                                                                             |
| `0x2F`                   | `orn`     | `orn <address> <number>`      | 将一个地址中的值与一个数字进行或运算，结果存储在该地址中。                                                                       |
| `0x30`                   | `xora`    | `xora <address> <address>`    | 将两个地址中的值进行异或运算，结果存储在第一个地址中。                                                                           |
| `0x31`                   | `xorn`    | `xorn <address> <number>`     | 将一个地址中的值与一个数字进行异或运算，结果存储在该地址中。                                                                     |
| `0x32`                   | `nota`    | `nota <address>`              | 对一个地址中的值进行非运算，结果存储在该地址中。                                                                                 |
| **比较指令**         |             |                                 |                                                                                                                                  |
| `0x33`                   | `equa`    | `equa <address> <address>`    | 比较两个地址中的值是否相等。条件成立时 `rs` 置 `1`，不成立时置 `0`。                                                       |
| `0x34`                   | `equn`    | `equn <address> <number>`     | 比较一个地址中的值是否等于一个数字。条件成立时 `rs` 置 `1`，不成立时置 `0`。                                               |
| `0x35`                   | `biga`    | `biga <address> <address>`    | 比较第一个地址中的值是否大于第二个地址中的值。条件成立时 `rs` 置 `1`，不成立时置 `0`。                                     |
| `0x36`                   | `bign`    | `bign <address> <number>`     | 比较一个地址中的值是否大于一个数字。条件成立时 `rs` 置 `1`，不成立时置 `0`。                                               |
| `0x37`                   | `bigequa` | `bigequa <address> <address>` | 比较第一个地址中的值是否大于等于第二个地址中的值。条件成立时 `rs` 置 `1`，不成立时置 `0`。                                 |
| `0x38`                   | `bigequn` | `bigequn <address> <number>`  | 比较一个地址中的值是否大于等于一个数字。条件成立时 `rs` 置 `1`，不成立时置 `0`。                                           |
| `0x39`                   | `smaa`    | `smaa <address> <address>`    | 比较第一个地址中的值是否小于第二个地址中的值。条件成立时 `rs` 置 `1`，不成立时置 `0`。                                     |
| `0x3A`                   | `sman`    | `sman <address> <number>`     | 比较一个地址中的值是否小于一个数字。条件成立时 `rs` 置 `1`，不成立时置 `0`。                                               |
| `0x3B`                   | `smaequa` | `smaequa <address> <address>` | 比较第一个地址中的值是否小于等于第二个地址中的值。条件成立时 `rs` 置 `1`，不成立时置 `0`。                                 |
| `0x3C`                   | `smaequn` | `smaequn <address> <number>`  | 比较一个地址中的值是否小于等于一个数字。条件成立时 `rs` 置 `1`，不成立时置 `0`。                                           |
| **内存直接操作指令** |             |                                 |                                                                                                                                  |
| `0x3D`                   | `seta`    | `seta <address> <address>`    | 将第二个地址中的值赋给第一个地址。                                                                                               |
| `0x3E`                   | `setn`    | `setn <address> <number>`     | 将一个数字赋给指定地址中的值。                                                                                                   |
| **内存间接操作指令** |             |                                 |                                                                                                                                  |
| `0x3F`                   | `geta`    | `geta <address1> <address2>`  | 取地址操作，将 `<address2>` 所存的值视作地址，取其指向的值放到 `address1` 的区域。                                           |
| `0x40`                   | `getn`    | `getn <address> <number>`     | 取地址操作，将 `number` 视作地址，取其指向的值放到 `address` 的区域。实际效果相当于 `seta`。                               |
| `0x41`                   | `puta`    | `puta <address1> <address2>`  | 存地址操作，将 `<address2>` 所存的值放入 `<address1>` 所存的值视作地址指向的区域。                                           |
| `0x42`                   | `putn`    | `putn <address> <number>`     | 存地址操作，将 `number` 放入 `<address>` 所存的值视作地址指向的区域。                                                        |
| **栈操作指令**       |             |                                 |                                                                                                                                  |
| `0x43`                   | `pusha`   | `pusha <address>`             | 将地址中的值压入栈，`sp` 自减 `1`。                                                                                          |
| `0x44`                   | `pushn`   | `pushn <number>`              | 将立即数压入栈，`sp` 自减 `1`。                                                                                              |
| `0x45`                   | `popa`    | `popa <address>`              | 从栈弹出值到指定地址，`sp` 自增 `1`。                                                                                        |
| `0x46`                   | `pop`     | `pop`                         | 从栈弹出值（丢弃），`sp` 自增 `1`。                                                                                          |
| **控制流指令**       |             |                                 |                                                                                                                                  |
| `0x47`                   | `jmpa`    | `jmpa <address>`              | 如果 `rs` 为 `1`，跳转到指定地址所存标签处，并将 `rs` 设置为 `0`。                                                       |
| `0x48`                   | `jmpn`    | `jmpn <label>`                | 如果 `rs` 为 `1`，跳转到指定标签处继续运行，并将 `rs` 设置为 `0`。                                                       |
| `0x49`                   | `ujmpa`   | `ujmpa <address>`             | 无条件跳转到地址中存储的位置。                                                                                                   |
| `0x4A`                   | `ujmpn`   | `ujmpn <label>`               | 无条件跳转到指定标签/地址。                                                                                                      |
| `0x4B`                   | `calla`   | `calla <address>`             | 调用地址中存储的函数地址，将返回地址 (`PC+3`) 压栈。                                                                           |
| `0x4C`                   | `calln`   | `calln <label>`               | 调用指定标签/地址的函数，将返回地址 (`PC+3`) 压栈。                                                                            |
| `0x4D`                   | `ret`     | `ret`                         | 从栈弹出返回地址并跳转。                                                                                                         |
| **I/O 指令**         |             |                                 |                                                                                                                                  |
| `0x4E`                   | `ina`     | `ina <address>`               | 从标准输入读取值到指定地址。                                                                                                     |
| `0x4F`                   | `inaasc`  | `inaasc <address>`            | 从标准输入按照 ASCII 读取值到指定地址。                                                                                          |
| `0x50`                   | `outa`    | `outa <address>`              | 输出指定地址中的值。                                                                                                             |
| `0x51`                   | `outn`    | `outn <number>`               | 直接输出一个数字。                                                                                                               |
| `0x52`                   | `outaasc` | `outaasc <address>`           | 以 ASCII 字符形式输出地址中的值（仅当值在有效 ASCII 范围内）。                                                                   |
| `0x53`                   | `outnasc` | `outnasc <number>`            | 以 ASCII 字符形式直接输出数字（仅当数字在有效 ASCII 范围内）。                                                                   |
| **特殊指令**         |             |                                 |                                                                                                                                  |
| `0x54`                   | `blta`    | `blta <address>`              | 内存块复制操作，需配合 `blts`（源地址）和 `bltl`（长度）指令，将 `blts` 存储的区域后 `bltl` 长的空间复制到 `address`。 |
